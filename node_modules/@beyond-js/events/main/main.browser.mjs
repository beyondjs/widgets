import * as dependency_0 from '@beyond-js/kernel/bundle';

const {Bundle: __Bundle} = dependency_0;
const __pkg = new __Bundle({"module":{"vspecifier":"@beyond-js/events@0.0.5/main"},"type":"ts"}, import.meta.url).package();;

__pkg.dependencies.update([]);

const ims = new Map();

/************************
INTERNAL MODULE: ./events
************************/

ims.set('./events', {hash: 3993267980, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Events = void 0;
/*bundle*/class Events {
  #specs;
  #listeners = new Map();
  #destroyed = false;
  get destroyed() {
    return this.#destroyed;
  }
  constructor(specs) {
    specs = specs ? specs : {};
    if (specs.supported && !(specs.supported instanceof Array)) throw new Error('Invalid parameters');
    this.#specs = specs;
    if (specs.bind) {
      specs.bind.bind = (event, listener, priority) => this.on(event, listener, priority);
      specs.bind.unbind = (event, listener) => this.off(event, listener);
    }
  }
  /**
   * Binds an event handler to an event name
   *
   * @param {string} event
   * @param {ListenerFunction} listener
   * @param {number} priority
   * @returns {this}
   */
  on(event, listener, priority) {
    if (this.#destroyed) {
      throw new Error('Events object is destroyed');
    }
    if (this.#specs.supported && !this.#specs.supported.includes(event)) {
      throw new Error(`Event "${event}" is not defined`);
    }
    if (typeof listener !== 'function') {
      throw new Error('Listener is not a function');
    }
    this.off(event, listener); // Just in case the listener is already registered
    const l = this.#listeners.has(event) ? this.#listeners.get(event) : [];
    this.#listeners.set(event, l);
    l.push({
      listener: listener,
      priority: priority ? priority : 0
    });
    return this;
  }
  bind = (event, listener, priority) => this.on(event, listener, priority);
  /**
   * Unbind an event listener
   *
   * @param {string} event
   * @param {ListenerFunction} listener
   * @param {number} force
   * @returns {this}
   */
  off(event, listener, force) {
    if (this.#destroyed) {
      throw new Error('Events object is destroyed');
    }
    if (!event) {
      throw new Error(`Event name not specified`);
    }
    if (this.#specs.supported && !this.#specs.supported.includes(event)) {
      throw new Error(`Event "${event}" is not defined`);
    }
    if (!listener) {
      if (!force) throw new Error('Listener function not set');
      this.#listeners.delete(event);
      return this;
    }
    if (!this.#listeners.has(event)) {
      return this;
    }
    const e = this.#listeners.get(event);
    const filtered = e.filter(item => item.listener !== listener);
    this.#listeners.set(event, filtered);
    return this;
  }
  unbind = (event, listener, force) => this.off(event, listener, force);
  /**
   * Triggers an event
   *
   * @param {Trigger} event
   * @param {*} rest
   * @returns {Promise<*>}
   */
  trigger(event, ...rest) {
    if (this.#destroyed) {
      throw new Error('Events object is destroyed');
    }
    event = typeof event === 'string' ? {
      'name': event
    } : event;
    if (typeof event !== 'object') throw new Error('Invalid parameters');
    if (typeof event.name !== 'string') throw new Error('Invalid event name');
    if (this.#specs.supported && !this.#specs.supported.includes(event.name)) {
      throw new Error(`Event "${event.name}" is not defined`);
    }
    let args = [...arguments];
    args.shift(); // Remove the event name from the list of arguments
    if (!this.#listeners.has(event.name)) return;
    let l = this.#listeners.get(event.name);
    // Sort by priority
    l.sort((a, b) => b.priority - a.priority);
    if (event.async) {
      const trigger = async function () {
        const promises = [];
        for (let listener of l) {
          promises.push(listener.listener(...args));
        }
        await Promise.all(promises);
      };
      return trigger.call(this, ...args).catch(exc => console.error(exc.stack));
    } else {
      for (let listener of l) {
        listener.listener(...args);
      }
    }
  }
  destroy() {
    this.#destroyed = true;
    this.#listeners.clear();
  }
}
exports.Events = Events;
globalThis.Events = Events;
}});

/***********************
INTERNAL MODULE: ./types
***********************/

ims.set('./types', {hash: 1632705009, creator: function (require, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
}});

__pkg.exports.descriptor = [{"im":"./events","from":"Events","name":"Events"},{"im":"./types","from":"ListenerFunction","name":"ListenerFunction"}];

export let Events, ListenerFunction;

// Module exports
__pkg.exports.process = function({require, prop, value}) {
    (require || prop === 'Events') && (Events = require ? require('./events').Events : value);
    (require || prop === 'ListenerFunction') && (ListenerFunction = require ? require('./types').ListenerFunction : value);

};
export const __beyond_pkg = __pkg;

export const hmr = new (function () {
    this.on = (event, listener) => void 0;
    this.off = (event, listener) => void 0;
});


__pkg.initialise(ims);
//# sourceMappingURL=main.browser.mjs.map